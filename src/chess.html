<html>
  <head>
    <title>Chess</title>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link type="text/css" href="css/custom-theme/jquery-ui-1.7.2.custom.css" rel="stylesheet" />  
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/jquery-ui.min.js"></script>
    <style>
      .board {width: 800px; height: 800px; border: 2px solid darkgrey; position: relative;}
      .square {float: left;}
      /*.wsq {background-color: lightgrey;}*/
      .wsq {background-image:url('images/white-marble.jpg');}
      /*.bsq {background-color: grey;}*/
      .bsq {background-image:url('images/grey-marble.jpg');}
      .dropHover {background-color: yellow; background-image: none}
      /*.dropActive {background-color: lightblue; background-image: none}*/
      .piece {position: absolute;}
      /*.wpc {background-color: white; color: black;}*/
      /*.bpc {background-color: black; color: white;}*/
    </style>
  </head>
  <body>
  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: "overlay"});</script>  
  <center>
    <div></div>
    <div class='board'>
    </div>
    <div><a href='#' id='undo'>Undo</a>&nbsp;<a href='#' id='reset'>Reset</a>&nbsp;<a href='#' id='flip'>Flip</a></div>
    <div id='info'></div>
  </center>
    <script>
      $(function() {
        var invert = false;
        var whitePieceType = 'paper', blackPieceType = 'cloth';
        var whiteMove = true;
        var board = $('.board');
        var boardData = [];
        var w = board.width(), h = board.height(), sw = w / 8, sh = h / 8, square;
        var moveList = [];
        function Move(piece, sourceSquare, firstMove, visible, takenPiece, passantPiece) {
            this.piece = piece;
            this.sourceSquare = sourceSquare;
            this.takenPiece = takenPiece;
            this.firstMove = firstMove;
            this.visible = visible;
            this.passantPiece = passantPiece;
        }

        // we've already eliminated:
        //  - white move on black's turn and vice versa
        //  - move from and to same square
        //  - taking your own peices
        function pieceBetween(sx, sy, tx, ty) {
            if(sy == ty) for(var x = sx + (tx > sx ? 1 : -1); x != tx; x = x + (tx > sx ? 1 : -1))
              if(boardData[sy][x].data('piece')) return true;
            if(sx == tx) for(var y = sy + (ty > sy ? 1 : -1); y != ty; y = y + (ty > sy ? 1 : -1))
              if(boardData[y][sx].data('piece')) return true;
            if(Math.abs(sx - tx) != Math.abs(sy - ty)) return false;
            var y = sy + (ty > sy ? 1 : -1);
            for(var x = sx + (tx > sx ? 1 : -1); x != tx; x = x + (tx > sx ? 1 : -1)) {
              if(boardData[y][x].data('piece')) return true;
              y = y + (ty > sy ? 1 : -1);
            }
            return false;
        }

        function legalMove(piece, targetSquare) {
            var sourceSquare = piece.data('square'),
              sx = sourceSquare.data('x'), 
              sy = sourceSquare.data('y'),
              tx = targetSquare.data('x'),
              ty = targetSquare.data('y');
            
            if(!piece.hasClass('knight') && pieceBetween(sx, sy, tx, ty)) return false;
            if(piece.hasClass('rook')) {
                return (sx == tx || sy == ty);
            } else if(piece.hasClass('knight')) {
                return ((Math.abs(sx - tx) == 2 && Math.abs(sy - ty) == 1)
                        || (Math.abs(sx - tx) == 1 && Math.abs(sy - ty) == 2));
            } else if(piece.hasClass('bishop')) {
                return (Math.abs(sx - tx) == Math.abs(sy - ty));
            } else if(piece.hasClass('queen')) {
                return ((sx == tx || sy == ty) || Math.abs(sx - tx) == Math.abs(sy - ty));
            } else if(piece.hasClass('king')) {
                if(piece.hasClass('hasMoved')) return (Math.abs(sx - tx) <= 1 && Math.abs(sy - ty) <= 1);
                if(!piece.hasClass('hasMoved')) {
                    if(sy != ty) return (Math.abs(sx - tx) <= 1 && Math.abs(sy - ty) <= 1);
                    if(Math.abs(sx - tx) == 1) return true;
                    if(Math.abs(sx - tx) == 2) { // castle
                      // king and rook may not capture during castle: http://www.chessvariants.com/d.chess/castlefaq.html
                      var isWhite = piece.hasClass('wpc');
                      if(tx > sx && !pieceBetween(sx, sy, 7, sy) && boardData[sy][7].data('piece') && !boardData[sy][7].data('piece').hasClass('hasMoved'))
                          return !(inDanger(sourceSquare, isWhite) || inDanger(boardData[sy][sx + 1], isWhite) || inDanger(targetSquare, isWhite));
                      if(tx < sx && !pieceBetween(sx, sy, 0, sy) && boardData[sy][0].data('piece') && !boardData[sy][0].data('piece').hasClass('hasMoved'))
                          return !(inDanger(sourceSquare, isWhite) || inDanger(boardData[sy][sx - 1], isWhite) || inDanger(targetSquare, isWhite));
                      return false;
                    }
                }
                
            } else if(piece.hasClass('pawn')) {
                if(piece.data('startY') == 1 && ty <= sy) return false;
                if(piece.data('startY') == 6 && ty >= sy) return false;
                if(Math.abs(sx - tx) > 1) return false;
                if(sx == tx) return (Math.abs(sy - ty) <= (piece.hasClass('hasMoved') ? 1 : 2) && !boardData[ty][tx].data('piece'));
                if(sx != tx) return (Math.abs(sy - ty) == 1 
                                     && (boardData[ty][tx].data('piece') 
                                         || (boardData[sy][tx].data('piece') 
                                             && boardData[sy][tx].data('piece').hasClass('passant'))));
            }
            return true;
        }

        function inDanger(square, isWhite) {
            var enemyPieces = $('.' + (isWhite ? 'bpc' : 'wpc'));
            for(var i = 0; i < enemyPieces.length; i++) {
                var piece = $(enemyPieces[i]);
                // creating check for yourself doesn't matter, according
                // to http://www.chessvariants.com/d.chess/faq.html
                if(legalMove(piece, square)) {// && !createsCheck(piece, square)) { 
                    return true;
                }
            }
            return false;
        }

        function createsCheck(piece, targetSquare) {
            // check for check
            // have to temporarily remove the piece and place it in the new spot
            var sourceSquare = piece.data('square');
            doMove(piece, targetSquare, false);
            var inCheck = false,
              isWhite = piece.hasClass('wpc');
            if(piece.hasClass('king')) {
                if(inDanger(targetSquare, isWhite)) 
                    inCheck = true;
            } else {
                var king = $('.' + (isWhite ? 'wpc' : 'bpc') + '.king'); 
                if(inDanger(king.data('square'), isWhite)) 
                    inCheck = true;
            }
            // restore state
            undoMove();
            return inCheck;
        }

        var types = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];

        function acceptFunc(piece) {
            if(piece.hasClass('wpc') != whiteMove) return false;
            var sq = $(this), sourceSquare = piece.data('square');
            if(sq.data('x') == sourceSquare.data('x') && sq.data('y') == sourceSquare.data('y')) return false;
            var targetPiece = sq.data('piece');
            if (targetPiece && (targetPiece.hasClass('wpc') == piece.hasClass('wpc'))) return false;
            if(legalMove(piece, sq)) return !createsCheck(piece, sq);
            return false;
        }

        function dropFunc(event, ui) {
          var targetSquare = $(this),
            piece = ui.draggable;
          doMove(piece, targetSquare, true);
        }

        function doMove(piece, targetSquare, visible) {
          var sourceSquare = piece.data('square');
          sourceSquare.removeData('piece');

          var passantPiece = $('.passant'); 

          var targetPiece = targetSquare.data('piece');
          if(!targetPiece && passantPiece && piece.hasClass('pawn') && sourceSquare.data('x') != targetSquare.data('x')) {
              // we are taking en passant
              targetPiece = passantPiece;
              targetPiece.data('square').removeData('piece');
          }
          if(targetPiece) targetPiece.hide();

          if(passantPiece) passantPiece.removeClass('passant');

          targetSquare.data('piece', piece);
          piece.data('square', targetSquare);

          // pawns are special
          if(piece.hasClass('pawn')) {
            //promote pawns
            if(Math.abs(sourceSquare.data('y') - targetSquare.data('y')) == 2) 
                piece.addClass('passant');
            if(Math.abs(piece.data('startY') - targetSquare.data('y')) == 6) {
              var isWhite = piece.hasClass('wpc');
              // TODO: allow promotion to rook, bishop, knight or queen
              piece.removeClass('pawn').addClass('queen')
                .html('<img src="images/' + (isWhite ? whitePieceType : blackPieceType) + '-queen.png" width="' + (sw) + '" height="' + (sh) + '"/>');
            }
          }

          if(piece.hasClass('king') && Math.abs(sourceSquare.data('x') - targetSquare.data('x')) == 2) {
              // castle
              var rook, nx, y = sourceSquare.data('y');
              if(targetSquare.data('x') > sourceSquare.data('x')) {
                  rook = boardData[y][7].data('piece');
                  nx = 5;
              } else {
                  rook = boardData[y][0].data('piece');
                  nx = 3;
              }
              rook.data('square').removeData('piece');
              rook.data('square', boardData[y][nx]);
              boardData[y][nx].data('piece', rook);
              rook.addClass('hasMoved');

              if(visible)
                rook
                  .css('left', '' + boardData[y][nx][0].offsetLeft + 'px')
                  .css('top', '' + boardData[y][nx][0].offsetTop + 'px');
          }

          var firstMove = !piece.hasClass('hasMoved');
          if(firstMove) piece.addClass('hasMoved');

          whiteMove = !whiteMove;

          if(visible)
            piece
              .css('left', '' + targetSquare[0].offsetLeft + 'px')
              .css('top', '' + targetSquare[0].offsetTop + 'px');
          moveList.push(new Move(piece, sourceSquare, firstMove, visible, targetPiece, passantPiece)); 
        }

        function undoMove() {
            if(moveList.length == 0) return;
            
            whiteMove = !whiteMove;

            var move = moveList.pop(),
              targetSquare = move.piece.data('square');
            if(move.visible)
              move.piece
                .css('left', '' + move.sourceSquare[0].offsetLeft + 'px')
                .css('top', '' + move.sourceSquare[0].offsetTop + 'px');

            move.piece.removeClass('passant');
            if(move.passantPiece) move.passantPiece.addClass('passant');
            targetSquare.removeData('piece');
            move.piece.data('square', move.sourceSquare);
            move.sourceSquare.data('piece', move.piece);
            if(move.takenPiece) {
                move.takenPiece.data('square').data('piece', move.takenPiece);
                // reset position in case the board has been flipped
                move.takenPiece
                  .css('left', '' + move.takenPiece.data('square')[0].offsetLeft + 'px')
                  .css('top', '' + move.takenPiece.data('square')[0].offsetTop + 'px');
                move.takenPiece.show();
            }
            if(move.firstMove) move.piece.removeClass('hasMoved');
            if(move.piece.hasClass('king') && Math.abs(targetSquare.data('x') - move.sourceSquare.data('x')) == 2) {
                // restore castle
                var rook, nx, y = move.sourceSquare.data('y');
                if(targetSquare.data('x') > move.sourceSquare.data('x')) {
                    rook = boardData[y][5].data('piece');
                    nx = 7;
                } else {
                    rook = boardData[y][3].data('piece');
                    nx = 0;
                }
                rook.data('square').removeData('piece');
                rook.data('square', boardData[y][nx]);
                boardData[y][nx].data('piece', rook);
                rook.removeClass('hasMoved');

                if(move.visible)
                  rook
                    .css('left', '' + boardData[y][nx][0].offsetLeft + 'px')
                    .css('top', '' + boardData[y][nx][0].offsetTop + 'px');
            }
        }

        // create the board
        function makePiece(x, y, isWhite, typ, square) {
          var img = ('<img src="images/' + (isWhite ? whitePieceType : blackPieceType) + '-' + typ + '.png" width="' + (sw) + '" height="' + (sh) + '"/>');
          var piece = $('<div class="piece ' + (isWhite ? 'wpc' : 'bpc') + ' ' + typ + '"/>')
            .css('width', '' + sw + 'px')
            .css('height', '' + sh + 'px')
            .data('square', square)
            .data('startY', y)
            .append(img);
          board.append(piece);
          // must be done after adding to board, or the position becomes relative?!?!
          piece.draggable({   containment: 'parent', 
                              stack: { group: '.piece', min: 1 },
                              revert: 'invalid' });
          square.data('piece', piece);
          return piece;
        }

        function placePieces() {
            for(var y = 0; y < 8; y++) {
                for(var x = 0; x < 8; x++) {
                    var square = boardData[y][x], piece = square.data('piece');
                    if(piece) 
                      piece
                        .css('left', '' + square[0].offsetLeft + 'px')
                        .css('top', '' + square[0].offsetTop + 'px')
                }
            }
          }

        for(var y = 0; y < 8; y++) {
          boardData[y] = [];
	        for(var x = 0; x < 8; x++) {
            var square = $('<div class="square ' + ((y + x) % 2 ? 'bsq' : 'wsq') + '"/>')
              .css('width', '' + sw + 'px')
              .css('height', '' + sh + 'px')
              .data('x', x)
              .data('y', y)
              .droppable({
                accept: acceptFunc,
                hoverClass: 'dropHover',
                //activeClass: 'dropActive',
                cursor: 'pointer',
                drop: dropFunc
              });
              //.html('(' + x + ', ' + y + ')');
            invert ? board.prepend(square) : board.append(square);
            
            boardData[y][x] = square;
            
            if(y == 0 || y == 7) {
              var typ = types[x];
              if(y == 0) makePiece(x, 0, false, typ, square);
              if(y == 7) makePiece(x, 7, true, typ, square);
            }
            else if(y == 1) makePiece(x, 1, false, 'pawn', square);
            else if(y == 6) makePiece(x, 6, true, 'pawn', square);
          }
        }

        placePieces();

        function flip() {
            invert = !invert;
            for(var y = 0; y < 8; y++) {
                for(var x = 0; x < 8; x++) {
                    var square = boardData[y][x];
                    //square.remove();
                    invert ? board.prepend(square) : board.append(square);
                    // recreate droppable (workaround reverted position bug?)
                    square.droppable('destroy');
                    square.droppable({
                        accept: acceptFunc,
                        hoverClass: 'dropHover',
                        //activeClass: 'dropActive',
                        cursor: 'pointer',
                        drop: dropFunc
                      });
                }
            }
            placePieces();
        }
        
        $('#undo').click(undoMove);
        $('#reset').click(function() {
            while(moveList.length) undoMove();
        });
        $('#flip').click(flip);
        
      });
    </script>
  </body>
</html>