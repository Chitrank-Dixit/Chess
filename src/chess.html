<html>
  <head>
    <title>Chess</title>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link type="text/css" href="css/custom-theme/jquery-ui-1.7.2.custom.css" rel="stylesheet" />  
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/jquery-ui.min.js"></script>
    <style>
    	div {margin-left: auto; margin-right: auto;}
      #board {width: 640px; height: 640px; border: 2px solid darkgrey; position: relative;}
      .square {float: left;}
      .dropHover {background-color: yellow;}
      /*.dropHover > img {display: none;}*/
      .dropHover > img {position: relative; top: 5%; left: 5%; width: 90%; height: 90%;}
      .piece {position: absolute;}
      div.text {text-align: center; padding: 1em;}
      #config {width: 800px;}
      #links {height: 2em;}
      #promoteDialog {width: 400px; height: 100px;}
    </style>
  </head>
  <body>
  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: "overlay"});</script>
  	<div id='promoteDialog' style='display: none'></div>
    <div id='top' class='text'>Welcome, {{user.nickname}}</div>
    <div id='board'>
    </div>
    <div id='links' class='text'>
    	<a href='#' id='undo'>Undo</a>&nbsp;
    	<a href='#' id='reset'>Reset</a>&nbsp;
    	<a href='#' id='flip'>Flip</a>&nbsp;
    	<img id='checkMark' src='images/red-check.jpg' height='100%' align='top' style='display:none'>
    	<img id='checkmateMark' src='images/skull.png' height='100%' align='top' style='display:none'>
    </div>
    <div id='config'>
    	<form id='configForm'>
 				<fieldset>
 					<table>
 						<tr>
 							<td><label for='wpcType'>White pieces:</label></td>
 							<td><select id='wpcType'>
 							  <option value='black'>Shiny black</option>
 							  <option value='caution'>Caution</option>
 							  <option value='cloth'>Cloth</option>
 							  <option value='denim'>Denim</option>
 							  <option value='glass'>Glass</option>
 							  <option value='greencheck'>Green check</option>
 							  <option value='metal'>Brushed metal</option>
 							  <option value='orange'>Fiery orange</option>
 							  <option value='paper'>Paper</option>
 							  <option value='purple'>Purple space</option>
 							  <option value='red'>Red</option>
 							  <option value='silver'>Silver</option>
 							  <option value='wood'>Wood</option>
 							</select></td>
 							<td><label for='bpcType'>Black pieces:</label></td>
 							<td><select id='bpcType'>
 							  <option value='black'>Shiny black</option>
 							  <option value='caution'>Caution</option>
 							  <option value='cloth'>Cloth</option>
 							  <option value='denim'>Denim</option>
 							  <option value='glass'>Glass</option>
 							  <option value='greencheck'>Green check</option>
 							  <option value='metal'>Brushed metal</option>
 							  <option value='orange'>Fiery orange</option>
 							  <option value='paper'>Paper</option>
 							  <option value='purple'>Purple space</option>
 							  <option value='red'>Red</option>
 							  <option value='silver'>Silver</option>
 							  <option value='wood'>Wood</option>
 							</select></td>
 							<td><label for='wsqType'>White squares:</label></td>
 							<td><select id='wsqType'>
	 							<option value='dark-wood.jpg'>Dark wood</option>
	 							<option value='grain-wood.jpg'>Grain wood</option>
	 							<option value='grey-marble.jpg'>Grey marble</option>
	 							<option value='grey-wood.jpg'>Grey wood</option>
	 							<option value='light-wood.jpg'>Light wood</option>
	 							<option value='white-marble.jpg'>White marble</option>
	 							<option value='grass1.jpg'>Grass 1</option>
	 							<option value='grass2.jpg'>Grass 2</option>
	 							<option value='grass3.jpg'>Grass 3</option>
	 							<option value='leaves1.jpg'>Leaves 1</option>
	 							<option value='leaves2.jpg'>Leaves 2</option>
 							</select></td>
 							<td><label for='bsqType'>Black squares:</label></td>
 							<td><select id='bsqType'>
	 							<option value='dark-wood.jpg'>Dark wood</option>
	 							<option value='grain-wood.jpg'>Grain wood</option>
	 							<option value='grey-marble.jpg'>Grey marble</option>
	 							<option value='grey-wood.jpg'>Grey wood</option>
	 							<option value='light-wood.jpg'>Light wood</option>
	 							<option value='white-marble.jpg'>White marble</option>
	 							<option value='grass1.jpg'>Grass 1</option>
	 							<option value='grass2.jpg'>Grass 2</option>
	 							<option value='grass3.jpg'>Grass 3</option>
	 							<option value='leaves1.jpg'>Leaves 1</option>
	 							<option value='leaves2.jpg'>Leaves 2</option>
 							</select></td>
 						</tr>
 					</table>
 				</fieldset>
    	</form>
    </div>
    <script>
      $(function() {
        var invert = false;
        var whitePieceType = 'paper', 
          blackPieceType = 'cloth',
          whiteSquareImage = 'light-wood.jpg',
          blackSquareImage = 'dark-wood.jpg';

        $('#wpcType').val(whitePieceType);
        $('#bpcType').val(blackPieceType);
        $('#wsqType').val(whiteSquareImage);
        $('#bsqType').val(blackSquareImage);

        function setOptions() {
            whitePieceType = $('#wpcType').val();
            blackPieceType = $('#bpcType').val();
            whiteSquareImage = $('#wsqType').val();
            blackSquareImage = $('#bsqType').val();
            setImages();
        }
        $('select').change(setOptions);

        var whiteMove = true;
        var board = $('#board');
        var boardData = [];
        var w = board.width(), h = board.height(), sw = w / 8, sh = h / 8, square;
        
        var moveList = [];
        function Move(piece, sourceSquare, firstMove, visible, takenPiece, passantPiece, promotion) {
            this.piece = piece;
            this.sourceSquare = sourceSquare;
            this.takenPiece = takenPiece;
            this.firstMove = firstMove;
            this.visible = visible;
            this.passantPiece = passantPiece;
            this.promotion = promotion;
        }

        // we've already eliminated:
        //  - white move on black's turn and vice versa
        //  - move from and to same square
        //  - taking your own peices
        function pieceBetween(sx, sy, tx, ty) {
            if(sy == ty) for(var x = sx + (tx > sx ? 1 : -1); x != tx; x = x + (tx > sx ? 1 : -1))
              if(boardData[sy][x].data('piece')) return true;
            if(sx == tx) for(var y = sy + (ty > sy ? 1 : -1); y != ty; y = y + (ty > sy ? 1 : -1))
              if(boardData[y][sx].data('piece')) return true;
            if(Math.abs(sx - tx) != Math.abs(sy - ty)) return false;
            var y = sy + (ty > sy ? 1 : -1);
            for(var x = sx + (tx > sx ? 1 : -1); x != tx; x = x + (tx > sx ? 1 : -1)) {
              if(boardData[y][x].data('piece')) return true;
              y = y + (ty > sy ? 1 : -1);
            }
            return false;
        }

        function legalMove(piece, targetSquare) {
            var sourceSquare = piece.data('square'),
              sx = sourceSquare.data('x'), 
              sy = sourceSquare.data('y'),
              tx = targetSquare.data('x'),
              ty = targetSquare.data('y');
            
            var targetPiece = targetSquare.data('piece');
            if (targetPiece && (targetPiece.hasClass('wpc') == piece.hasClass('wpc'))) return false;

            if(!piece.hasClass('knight') && pieceBetween(sx, sy, tx, ty)) return false;
            if(piece.hasClass('rook')) {
                return (sx == tx || sy == ty);
            } else if(piece.hasClass('knight')) {
                return ((Math.abs(sx - tx) == 2 && Math.abs(sy - ty) == 1)
                        || (Math.abs(sx - tx) == 1 && Math.abs(sy - ty) == 2));
            } else if(piece.hasClass('bishop')) {
                return (Math.abs(sx - tx) == Math.abs(sy - ty));
            } else if(piece.hasClass('queen')) {
                return ((sx == tx || sy == ty) || Math.abs(sx - tx) == Math.abs(sy - ty));
            } else if(piece.hasClass('king')) {
                if(piece.hasClass('hasMoved')) return (Math.abs(sx - tx) <= 1 && Math.abs(sy - ty) <= 1);
                if(!piece.hasClass('hasMoved')) {
                    if(sy != ty) return (Math.abs(sx - tx) <= 1 && Math.abs(sy - ty) <= 1);
                    if(Math.abs(sx - tx) == 1) return true;
                    if(Math.abs(sx - tx) == 2) { // castle
                      // king and rook may not capture during castle: http://www.chessvariants.com/d.chess/castlefaq.html
                      var isWhite = piece.hasClass('wpc');
                      if(tx > sx && !pieceBetween(sx, sy, 7, sy) && boardData[sy][7].data('piece') && !boardData[sy][7].data('piece').hasClass('hasMoved'))
                          return !(inDanger(sourceSquare, isWhite) || inDanger(boardData[sy][sx + 1], isWhite) || inDanger(targetSquare, isWhite));
                      if(tx < sx && !pieceBetween(sx, sy, 0, sy) && boardData[sy][0].data('piece') && !boardData[sy][0].data('piece').hasClass('hasMoved'))
                          return !(inDanger(sourceSquare, isWhite) || inDanger(boardData[sy][sx - 1], isWhite) || inDanger(targetSquare, isWhite));
                      return false;
                    }
                }
                
            } else if(piece.hasClass('pawn')) {
                if(piece.hasClass('bpc') && ty <= sy) return false;
                if(piece.hasClass('wpc') && ty >= sy) return false;
                if(Math.abs(sx - tx) > 1) return false;
                if(sx == tx) return (Math.abs(sy - ty) <= (piece.hasClass('hasMoved') ? 1 : 2) && !boardData[ty][tx].data('piece'));
                if(sx != tx) return (Math.abs(sy - ty) == 1 
                                     && (boardData[ty][tx].data('piece') 
                                         || (boardData[sy][tx].data('piece') 
                                             && boardData[sy][tx].data('piece').hasClass('passant'))));
            }
            return true;
        }

        function inDanger(square, isWhite, worryAboutCheck) {
            // use class piece to distinguish from taken peices
            var enemyPieces = $('.piece.' + (isWhite ? 'bpc' : 'wpc'));
            var checkers = [];
            for(var i = 0; i < enemyPieces.length; i++) {
                var piece = $(enemyPieces[i]);
                // enemy creating check for themselves doesn't matter, according
                // to http://www.chessvariants.com/d.chess/faq.html
                if(legalMove(piece, square) && (!worryAboutCheck || !createsCheck(piece, square))) { 
                    checkers.push(piece);
                }
            }
            if(checkers.length == 0)
              return false;
            return checkers;
        }

        function createsCheck(piece, targetSquare) {
            // check for check
            // have to temporarily remove the piece and place it in the new spot
            var sourceSquare = piece.data('square');
            doMove(piece, targetSquare, false);
            var inCheck = false,
              isWhite = piece.hasClass('wpc');
            if(piece.hasClass('king')) {
                if(inDanger(targetSquare, isWhite)) 
                    inCheck = true;
            } else {
                var king = $('.' + (isWhite ? 'wpc' : 'bpc') + '.king'); 
                if(inDanger(king.data('square'), isWhite)) 
                    inCheck = true;
            }
            // restore state
            undoMove();
            return inCheck;
        }

        function acceptFunc(piece) {
            if(piece.hasClass('wpc') != whiteMove) return false;
            var sq = $(this), sourceSquare = piece.data('square');
            if(sq.data('x') == sourceSquare.data('x') && sq.data('y') == sourceSquare.data('y')) return false;
            if(legalMove(piece, sq)) return !createsCheck(piece, sq);
            return false;
        }

        function dropFunc(event, ui) {
          var targetSquare = $(this),
            piece = ui.draggable;
          doMove(piece, targetSquare, true);
        }

        function checkCheck() {
            var king = $('.' + (whiteMove ? 'wpc' : 'bpc') + '.king');
            var square = king.data('square');
            checkers = inDanger(square, whiteMove);
            if(!checkers) {
              $('#checkMark').hide();
              $('#checkmateMark').hide();
              return;
            }
            
            var inCheck = true, inCheckmate = false;
            // check for checkmate
            // check if king can move
            var px = square.data('x'), py = square.data('y'),
              xmin = Math.max(px - 1, 0), xmax = Math.min(px + 1, 7),
              ymin = Math.max(py - 1, 0), xmax = Math.min(py + 1, 7),
              trapped = true;
            for(var x = xmin; x <= xmax && trapped; x++) {
                for(var y = ymin; y <= ymax && trapped; y++) {
                    if(x == px && y == py) continue;

                    var sq = boardData[y][x], targetPiece = sq.data('piece');
                    if(legalMove(king, sq) && !createsCheck(king, sq))
                        trapped = false;
                }
            }
            if(trapped) {
                // can we take the attacker, or interpose? not if there's more than one checker
                if(checkers.length > 1) inCheckmate = true;
                else {
                    if(!inDanger(checkers[0].data('square'), !whiteMove, true)) {
                        // can't take it - can we interpose?
                        // not if it's a knight
                        if(checkers[0].hasClass('knight')) inCheckmate = true;
                        else {
                            var cx = checkers[0].data('square').data('x'),
                              cy = checkers[0].data('square').data('y');
                            // not if it's adjacent
                            if(Math.abs(py - cy) <= 1 && Math.abs(px - cx) <= 1) inCheckmate = true;
                            else { // only leaves rooks, bishops, and queens
                                inCheckmate = true;
                                var xinc = (cx == px ? 0 : (cx > px ? 1 : -1)),
                                  yinc = (cy == py ? 0 : (cy > py ? 1 : -1));
                                var y = py + yinc;
                                for(var x = px + xinc; x != cx || y != cy; x = x + xinc) {
                                  if(inDanger(boardData[y][x], !whiteMove, true)) {
                                      inCheckmate = false;
                                      break;
                                  }
                                  y = y + yinc;
                                }
                            }
                        }
                    }
                }
            }
            if(inCheckmate) $('#checkmateMark').show();
            else $('#checkMark').show();
        }
        
        function doMove(piece, targetSquare, visible) {
          var sourceSquare = piece.data('square');
          sourceSquare.removeData('piece');

          var passantPiece = $('.passant'); 

          var targetPiece = targetSquare.data('piece');
          if(!targetPiece && passantPiece && piece.hasClass('pawn') && sourceSquare.data('x') != targetSquare.data('x')) {
              // we are taking en passant
              targetPiece = passantPiece;
              targetPiece.data('square').removeData('piece');
          }
          if(targetPiece) {
              targetPiece.hide();
              targetPiece.removeClass('piece');
          }

          if(passantPiece) passantPiece.removeClass('passant');

          targetSquare.data('piece', piece);
          piece.data('square', targetSquare);

          // pawns are special
          var promotion = false;
          if(piece.hasClass('pawn')) {
            if(Math.abs(sourceSquare.data('y') - targetSquare.data('y')) == 2) 
                piece.addClass('passant');
            if(visible && (targetSquare.data('y') == 0 || targetSquare.data('y') == 7)) {
              //promote pawns
              var isWhite = piece.hasClass('wpc'),
                pieceType = (isWhite ? whitePieceType : blackPieceType);
              promotion = true;
              $('#promoteDialog').empty()
                .append('<img class="promote queen" src="images/' + pieceType + '-queen.png" width="' + sw + '" height="' + sh + '"/>')
                .append('<img class="promote bishop" src="images/' + pieceType + '-bishop.png" width="' + sw + '" height="' + sh + '"/>')
                .append('<img class="promote knight" src="images/' + pieceType + '-knight.png" width="' + sw + '" height="' + sh + '"/>')
                .append('<img class="promote rook" src="images/' + pieceType + '-rook.png" width="' + sw + '" height="' + sh + '"/>')
                .dialog({
                  title: 'Pawn Promotion',
                  modal: true, resizable: false,
                  width: 'auto', height: 'auto',
                  promoteClass: 'queen',
                  open: function(event, ui) {
                    var _this = this;
                    $('.promote', $(this)).click(function() {
                        var promoteClass = $(this).removeClass('promote').attr('class');
                        console.log('assigned promotion value of ' + promoteClass);
                        $(_this).dialog('option', 'promoteClass', promoteClass);
                        $(_this).dialog('close');
                    });
                    $(this).show();
                  },
                  close: function() {
                    piece.removeClass('pawn').addClass($(this).dialog('option', 'promoteClass'))
                      .html('<img src="images/' + (isWhite ? whitePieceType : blackPieceType) + '-' + $(this).dialog('option', 'promoteClass') + '.png" width="100%" height="100%"/>');
                    $(this).dialog('destroy');
                  }
              });
            }
          }

          if(piece.hasClass('king') && Math.abs(sourceSquare.data('x') - targetSquare.data('x')) == 2) {
              // castle
              var rook, nx, y = sourceSquare.data('y');
              if(targetSquare.data('x') > sourceSquare.data('x')) {
                  rook = boardData[y][7].data('piece');
                  nx = 5;
              } else {
                  rook = boardData[y][0].data('piece');
                  nx = 3;
              }
              rook.data('square').removeData('piece');
              rook.data('square', boardData[y][nx]);
              boardData[y][nx].data('piece', rook);
              rook.addClass('hasMoved');

              if(visible)
                rook
                  .css('left', '' + boardData[y][nx][0].offsetLeft + 'px')
                  .css('top', '' + boardData[y][nx][0].offsetTop + 'px');
          }

          var firstMove = !piece.hasClass('hasMoved');
          if(firstMove) piece.addClass('hasMoved');

          whiteMove = !whiteMove;

          if(visible) {
            piece
              .css('left', '' + targetSquare[0].offsetLeft + 'px')
              .css('top', '' + targetSquare[0].offsetTop + 'px');
            checkCheck();
          }
          moveList.push(new Move(piece, sourceSquare, firstMove, visible, targetPiece, passantPiece, promotion)); 
        }

        function undoMove() {
            if(moveList.length == 0) return;
            
            whiteMove = !whiteMove;

            var move = moveList.pop(),
              targetSquare = move.piece.data('square');
            if(move.visible)
              move.piece
                .css('left', '' + move.sourceSquare[0].offsetLeft + 'px')
                .css('top', '' + move.sourceSquare[0].offsetTop + 'px');

            move.piece.removeClass('passant');
            if(move.passantPiece) move.passantPiece.addClass('passant');
            targetSquare.removeData('piece');
            move.piece.data('square', move.sourceSquare);
            move.sourceSquare.data('piece', move.piece);
            if(move.takenPiece) {
                move.takenPiece.data('square').data('piece', move.takenPiece);
                // reset position in case the board has been flipped
                move.takenPiece
                  .css('left', '' + move.takenPiece.data('square')[0].offsetLeft + 'px')
                  .css('top', '' + move.takenPiece.data('square')[0].offsetTop + 'px');
                move.takenPiece.show();
                move.takenPiece.addClass('piece');
            }
            if(move.firstMove) move.piece.removeClass('hasMoved');
            if(move.promotion) {
              var isWhite = move.piece.hasClass('wpc');
              move.piece.removeClass('queen bishop knight rook').addClass('pawn')
                .html('<img src="images/' + (isWhite ? whitePieceType : blackPieceType) + '-pawn.png" width="100%" height="100%"/>');
            }
            if(move.piece.hasClass('king') && Math.abs(targetSquare.data('x') - move.sourceSquare.data('x')) == 2) {
                // restore castle
                var rook, nx, y = move.sourceSquare.data('y');
                if(targetSquare.data('x') > move.sourceSquare.data('x')) {
                    rook = boardData[y][5].data('piece');
                    nx = 7;
                } else {
                    rook = boardData[y][3].data('piece');
                    nx = 0;
                }
                rook.data('square').removeData('piece');
                rook.data('square', boardData[y][nx]);
                boardData[y][nx].data('piece', rook);
                rook.removeClass('hasMoved');

                if(move.visible)
                  rook
                    .css('left', '' + boardData[y][nx][0].offsetLeft + 'px')
                    .css('top', '' + boardData[y][nx][0].offsetTop + 'px');
            }
            if(move.visible) checkCheck();
        }

        // create the board
        function makePiece(x, y, isWhite, typ, square) {
          var piece = $('<div class="piece ' + (isWhite ? 'wpc' : 'bpc') + ' ' + typ + '"/>')
            .css('width', '' + sw + 'px')
            .css('height', '' + sh + 'px')
            .data('square', square)
          board.append(piece);
          // must be done after adding to board, or the position becomes relative?!?!
          piece.draggable({   containment: 'parent', 
                              stack: { group: '.piece', min: 1 },
                              revert: 'invalid' });
          square.data('piece', piece);
          return piece;
        }

        function placePieces() {
            for(var y = 0; y < 8; y++) {
                for(var x = 0; x < 8; x++) {
                    var square = boardData[y][x], piece = square.data('piece');
                    if(piece) 
                      piece
                        .css('left', '' + square[0].offsetLeft + 'px')
                        .css('top', '' + square[0].offsetTop + 'px')
                }
            }
          }

        function setImages() {
            $('.wsq').html('<img src="images/' + whiteSquareImage + '" width="100%" height="100%" alt="white square"/>');
            $('.bsq').html('<img src="images/' + blackSquareImage + '" width="100%" height="100%" alt="black square"/>');
            var types = ['pawn', 'rook', 'knight', 'bishop', 'queen', 'king'];
            for(var i in types) {
              var typ = types[i];
              $('.wpc.' + typ).html('<img src="images/' + whitePieceType + '-' + typ + '.png" width="100%" height="' + sh + '" alt="white ' + typ + '"/>');
              $('.bpc.' + typ).html('<img src="images/' + blackPieceType + '-' + typ + '.png" width="100%" height="' + sh + '" alt="black ' + typ + '"/>');
            }
        }

        var rowTypes = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];

        for(var y = 0; y < 8; y++) {
          boardData[y] = [];
          for(var x = 0; x < 8; x++) {
            var isWhite = ((y + x) % 2 == 0);
            var square = $('<div class="square ' + (isWhite ? 'wsq' : 'bsq') + '"/>')
              .css('width', '' + sw + 'px')
              .css('height', '' + sh + 'px')
              .data('x', x)
              .data('y', y)
              .droppable({
                accept: acceptFunc,
                hoverClass: 'dropHover',
                cursor: 'pointer',
                drop: dropFunc
               });
              //.html('(' + x + ', ' + y + ')');
            invert ? board.prepend(square) : board.append(square);
            
            boardData[y][x] = square;
            
            if(y == 0 || y == 7) {
              var typ = rowTypes[x];
              if(y == 0) makePiece(x, 0, false, typ, square);
              if(y == 7) makePiece(x, 7, true, typ, square);
            }
            else if(y == 1) makePiece(x, 1, false, 'pawn', square);
            else if(y == 6) makePiece(x, 6, true, 'pawn', square);
          }
        }

        setImages();
        placePieces();

        function flip() {
            invert = !invert;
            for(var y = 0; y < 8; y++) {
                for(var x = 0; x < 8; x++) {
                    var square = boardData[y][x];
                    //square.remove();
                    invert ? board.prepend(square) : board.append(square);
                    // recreate droppable (workaround reverted position bug?)
                    square.droppable('destroy');
                    square.droppable({
                        accept: acceptFunc,
                        hoverClass: 'dropHover',
                        cursor: 'pointer',
                        drop: dropFunc
                      });
                }
            }
            placePieces();
        }
        
        $('#undo').click(undoMove);
        $('#reset').click(function() {
            while(moveList.length) undoMove();
        });
        $('#flip').click(flip);
        
      });
    </script>
  </body>
</html>